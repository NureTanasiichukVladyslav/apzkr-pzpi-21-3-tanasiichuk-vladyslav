Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА 
з навчальної дисципліни «Архітектура програмного забезпечення» 
Тема роботи: Програмна система для контролю стану умов існування тварин на фермах


Студент гр. ПЗПІ-21-3	_______________ Танасійчук В.Є.
							(підпис)
Керівник роботи	_______________ доц. Лещинська І.О.
							(підпис)

	Робота захищено «_» _____2024р. 
	з оцінкою ____________________
 
Комісія: 	_______________ доц. Лещинський В.О.
							(підпис)													_______________ доц. Лещинська І.О.
							(підпис)
	_______________ ст. викл. Сокорчук І.П.
							(підпис)

Харків
2024 р.
Харківський національний університет радіоелектроніки

Факультет  комп’ютерних наук		 Кафедра  програмної інженерії		
Спеціальність  121 – Інженерія програмного забезпечення					
Курс 		3             Семестр 					6					
Навчальна дисципліна  Архітектура програмного забезпечення				

ЗАВДАННЯ 
НА КУРСОВУ РОБОТУ СТУДЕНТА
 
Танасійчука Владислав Євгенійовича

1. Тема роботи: «Програмна система для контролю стану умов існування тварин на фермах»													
2. Термін узгодження завдання курсової роботи: «25» березня 2024 р.
3. Термін здачі студентом закінченої роботи: «14» червня 2024 р.
4. Вихідні дані до проєкту (роботи): В програмній системі передбачити можливість ведення списку тварин для догляду, сповіщення працівників про нестачу ресурсів в тварини, адміністрування системи. Використовувати ОС Windows 10, СКБД PostgreSQL, середовище розробки Visual Studio Code.	 
5. Зміст пояснювальної записки (перелік питань, що належить розробити): вступ, аналіз предметної області, постановка задачі, проєктування програмного проєкту, структура бази даних, розробка програмного проєкту, опис розробленої програмної системи, висновки, перелік посилань, додатки	
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень):
UML діаграма розгортання, UML діаграма прецедентів, ER модель даних, UML діаграма взаємодії, UML діаграма діяльності, UML діаграма компонентів.		 
КАЛЕНДАРНИЙ ПЛАН


№	Назва етапів курсової роботи	Термін виконання етапів роботи	Примітки
1	Функціональна специфікація програмного проєкту	25.03.24 – 30.03.24	виконано
2	Проєктування програмного проєкту	1.04.24 – 13.04.24	виконано
3	Кодування програмного проєкту	14.04.24 – 27.04.24	виконано
4	Оформлення пояснювальної записки	28.04.24 – 11.05.24	виконано
5	Захист курсової роботи	12.05.24 – 8.06.24	виконано

	Дата видачі завдання: «25» березня 2024 р.

	Керівник				_______________ доц. Лещинська І.О.
						(підпис)


	Студент гр. ПЗПІ-21-3	     ________________ Танасійчук В.Є.
						(підпис)

 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 73 с., 23 рис., 2 табл., 4 додатки, 5 джерел. 
АНАЛІТИКА, ВИД ТВАРИН, КОРИСТУВАЧ, ПОКАЗНИКИ, ПРОГРАМНА СИСТЕМА, СТАН ЗДОРОВ'Я, ТВАРИНА.

Об'єктом дослідження є індустрія сільського господарства, а саме актуальне на сьогоднішній день питання щодо організації моніторингу та контролю умов існування тварин на фермах. Особливу увагу приділено можливості персоналізації догляду за тваринами та забезпечення високого рівня їхнього здоров'я та продуктивності.
 Метою курсової роботи є розробка системи, яка дозволяє налаштувати роботу ферм, забезпечити моніторинг стану тварин у реальному часі за допомогою IoT пристроїв, створювати та оновлювати базу даних тварин і їхніх здоров'я, аналізувати зібрані дані, надавати сповіщення про критичні стани, а також забезпечити зручний доступ до інформації через веб-інтерфейс.
Методи розробки базуються на технологіях Next.js для клієнтської та Nest.js для серверної частин з використанням мови програмування TypeScript, серверу бази даних PostgreSQL, смарт-пристрій розроблено на мові програмування Rust. 
У результаті роботи здійснено програмну реалізацію системи для моніторингу стану умов існування тварин на фермах. Програмна система складається з вебзастосунку, сервера та IoT пристроїв.






ЗМІСТ


ВСТУП	7
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ	8
1.1 Бізнес-вимоги	8
1.1.1 Бізнес-можливості	8
1.1.2 Бізнес-цілі та критерії успіху	10
1.1.3 Потреби клієнтів або ринку	10
1.1.4 Бізнес-ризики	11
1.2 Концепція рішення	11
1.2.1 Окреслення концепції	11
1.2.2 Головна функціональність	12
1.2.3 Припущення та залежності	13
1.3 Рамки та обмеження проєкту	13
1.3.1 Рамки первинного випуску	13
1.3.2 Рамки наступних випусків	15
1.3.3 Обмеження та винятки	16
1.4 Бізнес-контекст	17
1.4.1 Профілі зацікавлених сторін	17
1.4.3 Робоче середовище	18
2 ПОСТАНОВКА ЗАДАЧІ	21
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ	22
3.1 Побудова ER-діаграми	22
3.2 Побудова логічної моделі бази даних на основі ER-діаграми	23
4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ	25
4.1 Архітектура серверної частини	25
4.2 Архітектура IoT частини	29
4.3 Архітектура клієнтської частини	33
5 ОПИС ПРОГРАМНОЇ СИСТЕМИ	37
5.1 Виклик і завантаження	37
5.2 Призначення і логічна структура	38
5.3 Опис програмної реалізації	39
ВИСНОВКИ	45
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	46
ДОДАТОК Б	47
ДОДАТОК В	61
ДОДАТОК Г	66

 
ВСТУП


У сучасному світі етика та добробут тварин стають все більш важливими питаннями. Споживачі все більше стурбовані умовами життя тварин на фермах, а законодавці вводять суворіші правила щодо поводження з тваринами. Це робить важливим для фермерів не лише забезпечувати продуктивність тваринництва, але й гарантувати, що тварини живуть у здорових та комфортних умовах.
Традиційні методи моніторингу стану тварин на фермах часто є трудомісткими, ненадійними та неточними. Працівники ферм повинні вручну спостерігати за тваринами, що може бути складно зробити, особливо на великих фермах. Цей метод також може бути суб'єктивним, оскільки різні працівники можуть по-різному інтерпретувати поведінку тварин.
Програмна система для контролю стану умов існування тварин на фермах може допомогти вирішити ці проблеми, надаючи об'єктивну та надійну інформацію про стан тварин. Система може збирати дані з різних датчиків, таких як датчики температури, вологості, та частоти серцевих скорочень, щоб створити комплексну картину стану тварин. Ці дані можуть бути використані для раннього виявлення проблем зі здоров'ям, покращення умов життя тварин та підвищення продуктивності тваринництва.
Окрім етичних міркувань, існує ряд економічних причин для впровадження програмної системи для контролю стану умов існування тварин на фермах. Хворі тварини можуть призвести до значних фінансових втрат через зниження продуктивності, витрати на лікування та ветеринарні послуги, а також через можливу загибель тварин.
Програмна система для контролю стану умов існування тварин на фермах може допомогти фермерам мінімізувати ці втрати, ранньо виявляючи проблеми зі здоров'ям тварин та вживаючи заходів для їх запобігання та забезпечуючи тваринам все необхідне для здорового росту та розвитку.
 
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Бізнес-вимоги
1.1.1 Бізнес-можливості


Головними конкурентними системами моніторингу стану тварин є Afimilk, SCP Dairy та DeLaval DelPro.
Afimilk - це система моніторингу корів, яка пропонує широкий спектр даних про активність, жування, поведінку та фізіологічні показники тварин. Ці дані дають фермерам комплексне уявлення про стан здоров'я та добробут своїх корів, що допомагає їм виявляти проблеми на ранній стадії, вживати заходів щодо запобігання та покращувати загальне управління стадом. Окрім того, Afimilk може оптимізувати процес доїння, що може призвести до збільшення надоїв та покращення якості молока.
Однак Afimilk має й деякі мінуси. Деякі фермери можуть вважати систему складною у використанні, особливо якщо вони не мають досвіду роботи з комп'ютерами або датчиками. До того ж, деякі дані, які збирає Afimilk, такі як жування, можуть бути неточними або важкими для інтерпретації. Це може обмежити корисність цих даних для фермерів.
SCR Dairy - це система моніторингу корів, яка дозволяє фермерам відстежувати рух та поведінку своїх тварин. Це допомагає виявляти проблеми зі здоров'ям, такі як кульгавість, мастит та респіраторні захворювання. Раннє виявлення цих проблем може допомогти фермерам вжити заходів щодо лікування тварин та запобігти поширенню хвороб. Окрім того, дані, зібрані SCR Dairy, можуть бути використані для оптимізації годівлі та управління стадом.
Однак SCR Dairy також має деякі мінуси. Система може бути дорогою в закупівлі та встановленні, що робить її недоступною для деяких фермерів. До того ж, камери та датчики SCR Dairy потребують регулярного обслуговування, що може бути додатковим тягарем для фермерів. Нарешті, деякі дані, які збирає SCR Dairy, такі як поведінка, можуть бути суб'єктивними та потребувати інтерпретації фермерами. Це може призвести до неточностей або помилок у прийнятті рішень.
DeLaval DelPro - це система моніторингу корів, яка збирає дані про якість молока, частоту доїння та стан вим'я. Ці дані допомагають фермерам покращити якість молока та оптимізувати процес доїння, що може призвести до збільшення доходів та покращення репутації ферми. DeLaval DelPro також може допомогти у ранньому виявленні проблем зі здоров'ям вим'я, таких як мастит.
Однак DeLaval DelPro має й мінус - система може бути дорогою в закупівлі та встановленні, що робить її недоступною для деяких фермерів.
Також спільним мінусом всіх систем аналогів є орієнтованість лише на корів, вони не підтримують можливість використання для догляду за іншими свійськими тваринами.
На відміну від конкурентів, які зосереджені лише на певному типі тварин, наша система пропонує фермерам універсальне рішення для догляду за різними видами свійських тварин, включаючи свиней, кіз, овець, птахів та інших. Це робить її практичною та вигідною для фермерів, які мають різнопрофільне стадо, адже їм не потрібно купувати та обслуговувати окремі системи для кожного виду тварин.
Зручний мобільний додаток з інтуїтивно зрозумілим інтерфейсом, робить систему доступною та простою у використанні навіть для фермерів з обмеженими технічними знаннями. Це знижує бар'єри для впровадження та робить нашу систему привабливою для ширшого кола користувачів.
Наша модель монетизації передбачає отримання прибутку з продажів IoT пристроїв та надання технічної підтримки в обслуговуванні та користуванні системою.





1.1.2 Бізнес-цілі та критерії успіху

BO-1: Сформувати першу базу клієнтів, які будуть користуватися нашою системою.
BO-2: Покращити IoT прилади відповідно до відгуків клієнтів.
BO-3: Розширити ринкову присутність: Вийти на європейський ринок, адже там більш розвинута етика щодо поводження з тваринами.
SC-1: Кількість користувачів: За перший рік укласти співпрацю щонайменше з 50 фермами.
SC-2: Початок прибутку: за перший рік випуску продукту, відбити кошти витрачені на його виробництво.
SC-3: Збільшення використання пристроїв: забезпечити, щоб не менше ніж 50% фермерів, які вже користуються системою купили додаткові пристрох для більшої кількості тварин.
SC-4: Задоволеність клієнтів: Забезпечити середню оцінку задоволеності користувачів продуктом не менше 4 з 5 протягом першого року. 


1.1.3 Потреби клієнтів або ринку


Потреби клієнтів:
-	точність зібраних даних: високоякісні датчики для збору точних даних про здоров'я, поведінку та продуктивність тварин, а також регулярне калібрування та обслуговування для гарантії точності даних;
-	зручний інтерфейс: Простий та інтуїтивно зрозумілий інтерфейс для легкого доступу та аналізу даних, чіткі візуалізації даних (графіки та діаграми) для легшого сприймання інформації.
-	  збір різних метрик в одному місці: клієнтам потрібен комплексний набір даних про фізіологічні показники, активність, поведінку та продуктивність тварин;


1.1.4 Бізнес-ризики


Ризики:
-	конкуренція з іншими системами для догляду за тваринами;
-	не бажання фермерів переходити на нашу систему, якщо вони вже використовують іншу;
-	ускладнення під час впровадження або неуспішне впровадження системи;
-	неправильна робота IoT застосунків;

Можливі заходи:
-	маркетингова компанія;
-	проведення безкоштовного тестування системи серед групи бажаючих фермерів для виявлення можливих проблем та вдосконалення продукту перед повним випуском;
-	надання технічної підтримки клієнтам;
-	постійне виправлення недоліків роботи застосунку;


1.2 Концепція рішення
1.2.1 Окреслення концепції


Головна ціль програмної системи, яку ми розробляємо, це полегшення роботи фермерів з догляду за станом умов існування тварин на фермах. Наш продукт надасть зручний інструмент для відстеження та аналізу різних параметрів тварин, дозволяючи фермерам легше доглядати за ними. Основною переваги нашої програмної системи є простий інтерфейс та можливість відслідковування показників тварин у реальному часі , завдяки цьому фермери можуть оперативно реагувати на будь-які зміни та проблеми у тварин.


1.2.2 Головна функціональність


MF1.	Автоматизований моніторинг:
Система автоматично вимірює та відстежує:
-	Температуру тіла тварини.
-	Частоту серцевих скорочень та дихання тварини.
-	Температуру в ангарі проживання тварин.
-	Прийом їжі та води тваринами.
MF2.	Профілі тварин: фермери можуть створювати профілі для кожної тварини, вказуючи її конкретні дані.
MF3.	Сповіщення: система інформує фермерів про порушення умов проживання тварин.
MF4.	Аналітика стану тварин на основі зібраних даних
MF5.	Підтримка моніторингу стану різних видів тварин.
MF5.      Довідник з користування: інформація з інструкцією з користування застосунком.	
MF6.  Локалізація: система, підтримує англійську та українську мови, для зручного використання користувачами з різних країн.



1.2.3 Припущення та залежності


П-1: Клієнти мають стабільне підключення до Інтернету для користування системою.
П-2:  Користувач ознайомився з функціоналом застосунку та датчиків.
П-3: Тварини комфортно переносять датчики, не відчуваючи дискомфорту чи стресу. 
З-1: Застосунок потребує наявність сумісних датчиків для збору даних з тварини. 
З-2: Ефективність системи залежить від якості встановлення і налаштування датчиків. 
 З-3: Користувачі повинні регулярно оновлювати програмне забезпечення.


1.3 Рамки та обмеження проєкту
1.3.1 Рамки первинного випуску


Серверна частина має містити:
Реєстрація та авторизація користувачів:
-	За допомогою JWT (JSON Web Token)
Управління тваринами:
-	Створення та редагування профілів тварин.
-	Збір та обробка даних з датчиків: температура, частота серцевих скорочень, активність.
Аналітика даних:
-	Зберігання даних
-	Виявлення аномалій: відхилення від нормальних параметрів.
-	Оцінка стану здоров'я: раннє виявлення проблем зі здоров'ям.
-	Прогнозування: передбачення майбутніх проблем.
Сповіщення:
-	Автоматичне надсилання сповіщень про незадовільний стан тварин.
Адмін панель:
-	Управління користувачами системи.
-	Створення резервних копій бази даних.
Безпека:
-	Шифрування конфіденційних даних, з використання сучасних алгоритмів, таких як таких як SHA256.
-	Регулярне резервне копіювання даних.
-	Контроль доступу за ролями.
Функціонал IoT пристрою має містити:
Збір даних про:
-	Температуру тіла тварини та ангару, де вона проживає.
-	Частота серцевих скорочень та дихання.
-	Прийоми їжі та води.
Комунікація із сервером відбувається за допомогою HTTP-запитів.
Front-end частина має містити:
Користувач:
-	Реєстрація та вхід користувача.
-	Управління профілями тварин.
-	Перегляд візуалізованих даних із IoT пристроїв для кожної з тварин або ангарів.
-	Отримання сповіщень про незадовільний стан тварин.
Адмін:
-	Реєстрація та вхід адміна.
-	Управління користувачами системи.
-	Створення резервних копій бази даних.
Також має бути реалізована локалізація та інтернаціоналізація: підтримка англійської та української мови.
Mobile частина має містити:
-	Реєстрація та вхід користувача.
-	Управління профілями тварин.
-	Перегляд візуалізованих даних із IoT пристроїв для кожної з тварин або ангарів.
-	Отримання сповіщень на телефон про незадовільний стан тварин.
Також має бути реалізована локалізація та інтернаціоналізація: підтримка англійської та української мови.


1.3.2 Рамки наступних випусків


Серверна частина має містити:
Рекомендації:
-	На основі зібраних даних, видавати рекомендації щодо догляду за твариною.
-	Покращити аналіз даних відповідно до особливостей різних типів тварин.
Персоналізація параметрів:
-	Користувач має змогу ставити власні параметри та їх прийнятні значення для кожної з тварин.
-	Покращити аналіз даних відповідно до персоналізованих параметрів.
Функціонал IoT пристрою має містити:
GPS-трекер:
-	Фермер зможе відслідковувати де знаходиться тварина.
-	На основі даних зібраних трекером можна проаналізувати активність тварини.
Адаптувати пристрої до тварин:
-	Зробити пристрої більш витривалими до пошкоджень.
-	Зробити пристрої приємнішими для тварини.
Front-end та Mobile частини мають містити:
Візуалізація даних:
-	Дані мають бути візуалізовані за допомогою графіків та діаграм для легшого сприйняття інформації.
Рекомендації:
-	Користувач має змогу переглянути рекомендації щодо догляду за твариною на основі зібраних даних.
Персоналізація параметрів:
-	Користувач має змогу ставити власні параметри та їх прийнятні значення для кожної з тварин.


1.3.3 Обмеження та винятки


−	якість підключення до мережі: якщо тварина вільно гуляє, то пристрій може не мати доступу до Інтернету;
−	правильне підключення датчиків: для роботи зі застосунком фермер має правильно одягнути та активувати всі датчики;
−	тварина може пошкодити пристрої;
−	необхідність ретельного тестування датчиків, адже на відміну від мобільного та веб застосунків його збої не вийде легко виправити після покупки клієнтом


1.4 Бізнес-контекст
1.4.1 Профілі зацікавлених сторін


Таблиця 1 – Профілі зацікавлених сторін 
Зацікавлена сторона	Головна цінність	Ставлення	Головний інтерес	Обмеження
Власники ферм	Збільшення продуктивності працівників та покращення умов життя тварин.	Очікування системи, яка полегшить догляд за тваринами.	Збільшення прибутків та продуктивності бізнесу.	Доступ до інтернету.
Працівники ферм	Полегшення роботи, збільшення продуктивності.	Очікування системи, яка полегшить догляд за тваринами.	Простий та зрозумілий застосунок, який полегшує догляд за тваринами.  	Доступ до Інтернету
Розробник проєкту	Можливість заробити та створити корисний продукт.	Зацікавленість в фінансовому успіху та збільшенні репутації розробника.	Заробіток	Нестача досвіду у розробці, маркетингу.
1.4.2 Пріоритети проєкту


Таблиця 2 – Основні пріорітети проєкту 
Показник	Виконання
(етапи)	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
План	Реліз 1.0 має бути випущеним до 10.06.2024		
Функціональність			90% функціоналу має працювати на релізі 1.0
Якість			На релізі 1.0 має бути пройдено 100% тестів
Персонал		Максимальний розмір команди це один розробник	
Ціна			Можливе збільшення на 15%


1.4.3 Робоче середовище


Cерверна частина: 
-	Для створення серверної частини проекту буде використано фреймворк Nest.js [2] з використанням мови програмування TypeScript [1]. Ці технології забезпечать модульну, масштабовану та безпечну програму.
Клієнтська частина: 
-	Для створення клієнтської частини проекту буде використано фреймворк Next.js [3] з використанням мови програмування TypeScript. Nest.js забезпечить server-side rendering для швидкого завантаження сторінок та SEO, client-side routing для плавної навігації, data fetching для ефективного завантаження даних
Мобільний застосунок: 
-	Для створення мобільної версії застосунку буде використана платформа MAUI з використанням мови програмування C#.
Пристрій IoT: 
-	Для реалізації IoT-частини продукту буде використано Raspberry Pi з використанням мови програмування  Rust [4].
База даних: 
-	PostgreSql [5]. Це гарантує високу надійність, масштабованість та підтримку ACID-транзакцій.
Хмарні сервіси: 
-	Front-end: частина буде розташована на сервісі Vercel. Він забезпечить швидке та безпечне розгортання та хостинг, а також CI/CD за допомогою Git-інтеграції. Також великим плюсом є глобальна мережа CDN, це покращує швидкість завантаження та зменшує затримку.
-	Серверна частина: буде завантажена на AWS. Він гарантує масштабованість, надійність, високий рівень безпеки з сертифікатами SSL та протоколами шифрування, а також глобальну інфраструктуру з центрами обробки даних по всьому світу.
Забезпечення безпеки: 
-	HTTPS: шифрування даних під час передачі. 
-	Аутентифікація та авторизація: впровадження сучасних методів аутентифікації та авторизації для захисту від несанкціонованого доступу.
Доступність та надійність: 
-	Серверна частина системи буде розміщена на серверах AWS з з глобальною інфраструктурою по всьому світу,можливістю швидкого масштабування, створення резервних копій та аварійного відновлення. 
-	Клієнтська частина системи буде розміщена на серверах Vercel з можливістю аварійного відновлення. 
-	Застосунок буде доступний для користувачів цілодобово без перерв у роботі.

 
2 ПОСТАНОВКА ЗАДАЧІ


Проаналізувавши предметну області, задачею курсової роботи було поставлено створення програмної системи для контролю стану умов існування тварин на фермах.
Функціонал клієнта:
-	реєстрація та вхід в систему;
-	перегляд додавання, редагування, видалення тварин на фермі;
-	перегляд додавання, редагування, видалення видів тварин;
-	приєднання та налаштування датчиків;
-	перегляд зібраних показників;
-	перегляд аналізу та стану тварини на основі зібраних показників;
-	отримання сповіщень якщо стан якоїсь з тварин незадовільний;
Для адміністратора системи має бути реалізований такий функціонал:
-	реєстрація та вхід в систему;
-	перегляд додавання, редагування, видалення тварин на фермі;
-	експорт даних системи для резервного копіювання;
Система повинна підтримувати українську та англійську мови, правильно відображати текст з різними кодовими таблицями символів, а також обчислювати та форматувати дату та час відповідно до локальних налаштувань.  
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ
3.1 Побудова ER-діаграми


ER-модель (див. рис. 3.1). складається з 7 сутностей: Animal (Тварина), AnimalSpecies (Вид тварин), Notification(Сповіщення), Role (Роль користувача), Metrics(Показники), User(Користувач), Device(Пристрій). Було виділено наступні зв’язки:
1.	Користувач (User) - Роль (Role):
•	Один до багатьох (1:N)
•	Один користувач може мати одну або декілька ролей.
•	Кожна роль може бути призначена одному або декільком користувачам.
2.	 Користувач (User) - Тварина (Animal):
•	Один до багатьох (1:N)
•	Один користувач може володіти однією або декількома тваринами.
•	Кожна тварина належить одному користувачу.
3.	 Тварина (Animal) - Вид тварини (AnimalSpecies):
•	Один до одного (1:1)
•	Кожна тварина належить одному виду тварин.
•	Кожен вид тварин може мати одну або декілька тварин.
4.	 Тварина (Animal) - Показник (Metric):
•	Один до багатьох (1:N)
•	Одна тварина може мати один або декілька показників.
•	Кожен показник належить одній тварин.
5.	 Тварина (Animal) - Пристрій (Device):
•	Один до багатьох (1:N)
•	Одна тварина може мати один або декілька пристроїв.
•	Кожен пристрій належить одній тварин.
6.	 Користувач (User) - Сповіщення (Notification):
•	Один до багатьох (1:N)
•	Один користувач може отримати одне або декілька повідомлень.
•	Кожне повідомлення може бути направлене одному користувачу.
7.	 Тварина (Animal) - Сповіщення (Notification):
•	Один до багатьох (1:N)
•	Одна тварина може бути згадана в одному або декількох повідомленнях.
•	Кожне повідомлення може стосуватися однієї або декількох тварин.

 
Рисунок 3.1 – ER-модель бази даних програмної системи для контролю стану умов існування тварин на фермах


3.2 Побудова логічної моделі бази даних на основі ER-діаграми


На основі розробленої ER-діаграми було розроблено схему майбутньої реляційної бази даних, яка містить такі таблиці: Animal (Тварина), AnimalSpecies (Вид тварин), Notification (Сповіщення), Role (Роль користувача), Metrics (Показники), User (Користувач), Device (Пристрій) (див. рис. 3.2).

 
Рисунок 3.2 – Схема бази даних програмної системи для контролю стану умов існування тварин на фермах

Усі таблиці було спроектовано відповідно реляційній моделі. Кожна таблиця відповідає третій нормальній формі, тобто таблиці є відношеннями, атрибути повно функціонально залежать від первинних ключів та не мають транзитивної залежності.


 
4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
4.1 Архітектура серверної частини


Користувачами розробленої системи є 2 типи акторів: клієнт та адміністратор. 
Основними потребами клієнта є: 
-	можливість моніторингу стану тварин;
-	додавання, редагування, видалення тварин;
-	отримання показників стану здоров'я тварини в реальному часі;
-	отримання аналізу та статистики щодо зібраних показників:
-	додавання, редагування нових видів тварин та норми показників для них;
-	отримання сповіщень про незадовільний або критичний стан здоров'я тварини;
Основними потребами адміністратора є: 
-	можливість створення резервних копій даних системи
-	додавання, редагування нових видів тварин та норми показників для них;
На основі цього було зроблено діаграму прецедентів (див. рис. 4.1).

 
Рисунок 4.1 – Діаграма прецедентів серверної частини програмної системи
UML діаграма розгортання програмної системи для контролю стану умов існування тварин на фермах (див. рис. 4.2).
Для розробки серверної частини системи обрано мову програмування TypeScript та фреймворк Nest.js. 
Для зберігання даних обрано базу даних PostgreSQL, адже вона гарантує високу надійність, масштабованість та підтримку ACID-транзакцій, а також СУБД Prisma. 
Для забезпечення інтернаціоналізації, в базі даних можуть зберігатись тексти з символами будь-якої мови, а також всі дати будуть зберігатись в форматі UTC. 
Для забезпечення локалізації було використано метод рядкової локалізації, коли записи для різних мов зберігаються в базі даних.

 
Рисунок 4.2 – UML діаграма розгортання серверної частини

У застосунку було використано архітектурний шаблон Clean Architecture. Застосунок складається з 5 шарів: Presentation Layer, Application Layer, Domain Layer та Data Access Layer. 
Presentation layer включає в себе контролери, які приймають та оброблюють запити від користувачів.
•	Цей шар відповідає за взаємодію з користувачем через контролери API.
•	Контролери приймають HTTP-запити, обробляють їх та повертають відповіді.
•	Цей шар не містить жодної бізнес-логіки, а лише делегує її сервісам Application Layer. 
Application layer містить сервіси, що реалізують бізнес-логіку додатку.
•	Цей шар містить сервіси, які реалізують бізнес-логіку додатку.
•	Сервіси використовують сутності Domain Layer для виконання своїх функцій.
•	Цей шар не залежить від будь-яких технологій зберігання даних або інтерфейсів користувача.
Domain layer визначає сутності застосунку. 
•	Цей шар визначає сутності та правила бізнес-домену.
•	Сутності представляють ключові поняття та їх атрибути.
•	Правила визначають поведінку та обмеження для сутностей.
•	Цей шар не залежить від жодних технологій реалізації.
Data access layer відповідає за доступ до даних, для цього було використано PrismaORM.
•	Цей шар відповідає за доступ до даних, використовуючи PrismaORM.
•	Він використовує інтерфейси та сутності Domain Layer для взаємодії з базою даних.
•	Цей шар абстрагує деталі реалізації зберігання даних від інших шарів
Архітектуру системи зображео на UML діаграмі пакетів програмної системи для контролю стану умов існування тварин на фермах (див. рис. 4.3).

 
Рисунок 4.3 – Діаграма пакетів серверної частини програмної системи

Приклади частин коду серверного застосунка представлено у додатку Б.
Таким чином, було визначено технології й архітектуру серверної частини програмної системи.


4.2 Архітектура IoT частини


Користувачами Iot частини розробленої системи є 2 типи акторів: користувач та сам Iot пристрій. Користувач може : налаштовувати пристрій; Пристрій може: реєструватись та авторизовуватись на сервері, заміряти показники стану здоров'я тварини; відправляти зібрані показники на сервер. 
Взаємодію кожної ролі користувачів з системою представлено на діаграмі прецедентів (див. рис. 4.4).

 
Рисунок 4.4 – Діаграма прецедентів IoT частини програмної системи

Для розробки IoT частини системи було обрано мову програмування Rust. Rust - це системна мова програмування, яка поєднує в собі високу продуктивність, безпеку пам'яті та зручність використання. Її особливості роблять її гарним вибором для розробки вбудованого програмного забезпечення, такого як IoT пристрої. Для демонстрації введення та виведення інформації використовується cli інтерфейс.
Відправка оброблених даних на сервер реалізована за допомогою бібліотеки Reqwest. Ця бібліотека надає функції для надсилання HTTP-запитів у різних форматах, включаючи JSON.
Дані надсилаються на сервер у форматі JSON. Для серіалізації та десеріалізації даних JSON використовується бібліотека Serde.
IoT частина системи складається з наступних компонентів:
-	Модуль збору даних: Цей модуль відповідає за збір даних з датчиків IoT пристрою.
-	Модуль обробки даних: Цей модуль обробляє дані, зібрані модулем збору даних. Він може виконувати такі операції, як фільтрація, агрегування та перетворення даних.
-	Модуль відправки даних: Цей модуль надсилає оброблені дані на сервер. Він використовує бібліотеку Reqwest для надсилання HTTP-запитів.
Візуалізація архітектури та використаних технологій представлено на діаграмі пакетів (див. рис. 4.5).

 
Рисунок 4.5 – Діаграма пакетів для IoT приладу

Взаємодія пристроя з користувачем починається з його увімкненняю Потім користувач має задати налаштування системи та підключитись до WiFi. Якщо це перше увімкнення пристрою, то він має пройти реєстрацію на сервері. Після цього пристрій може почати збір та надсилання метрик. На основі описаної взаємодії пристрою с користувачем було побудовано діаграму взаємодії (див. рис. 4.6).

 
Рисунок 4.6 – Діаграма взаємодії для IoT приладу

Також було побудовано діаграму діяльності, що відображає взаємодію пристрою з сервером (див. рис. 4.7). 
 
Рисунок 4.7 – Діаграма діяльності для IoT приладу

Приклади коду IoT частини системи представлено у додатку В.


4.3 Архітектура клієнтської частини


Користувачами розробленої системи є 2 типи акторів: клієнт та адміністратор. 
Основними потребами клієнта є: 
-	можливість моніторингу стану тварин;
-	додавання, редагування, видалення тварин;
-	отримання показників стану здоров'я тварини в реальному часі;
-	отримання аналізу та статистики щодо зібраних показників:
-	додавання, редагування нових видів тварин та норми показників для них;
-	отримання сповіщень про незадовільний або критичний стан здоров'я тварини;
Основними потребами адміністратора є: 
-	можливість створення резервних копій даних системи
-	додавання, редагування нових видів тварин та норми показників для них;
На основі цього було зроблено діаграму прецедентів (див. рис. 4.8).
 
Рисунок 4.8 – Діаграма прецедентів клієнтської частини програмної системи
Для написання клієнтської частини системи було обрано мову програмування TypeScript з використанням Next.js, фреймворку для React, що забезпечує високу продуктивність додатку та зручність у розробці та тестуванні за рахунок статичної типізації та компонентного підходу. Next.js зокрема надає власну, вже реалізовану систему навігації по сайту.
Також Next.js надає власний компілятор та пакувальник Turbopack, які значно швидші за аналоги.
Для реалізації елементів інтерфейсу було використано бібліотеку Material UI, яка  надає стилізовані компоненти інтерфейсу, в загальному дизайні, який розробили в компанії Google. 
Для реалізації локалізації інтерфейсу було використано бібліотеку i18next, що легко інтегрується до проекту та реалізує зручний підхід до локалізації. 
Для виконання асинхронних запитів на сервер використано вбудований в JavaScript метод fetch, який не потребує додаткових бібліотек. 
Візуалізація архітектури та використаних технологій представлено на діаграмі пакетів (див. рис. 4.9) 

Рисунок 4.9 – Діаграма пакетів для клієнтської частини програми

Взаємодія користувача з сайтом починається з входу у систему. Потім взаємодія користувача розділяється на адміністраторську та клієнтську ролі. Клієнт може переглядати та керувати списком тварин (створювати, редагувати, видаляти), а також переглядати детальну статистику та аналіз показників кожної з тварин. Також користувач може переглядати сповіщення про стан тварин, які йому надсилає програмна система. Адміністратор може експортувати базу даних, для резервного копіювання. В незалежності від ролі користувачі можуть переглядати та керувати видами тварин, які доступні в системі(клієнт лише власні, адмін будь-які). На основі описаної взаємодії пристрою с користувачем було побудовано діаграму взаємодії (див. рис. 4.10)

Рисунок 4.10 – Діаграма взаємодії для клієнтської частини програми

Також для більш детальної візуалізації архітектури системи та взаємодії її частин було розроблено діаграму компонентів (див. рис. 4.11).

 Рисунок 4.11 – Діаграма компонентів для клієнтської частини програми

Приклади коду клієнтської частини системи представлено у додатку Г.
 

5 ОПИС ПРОГРАМНОЇ СИСТЕМИ
5.1 Виклик і завантаження


Спочатку необхідно завантажити код програми з GitHub. Завантажте та встановіть Rust з офіційного сайту https://www.rust-lang.org/. Завантажте та встановіть Docker з офіційного сайту https://docs.docker.com/compose/install/.
Щоб програма працювала необхідно створити .env файл для серверної частини в якому вказати дані користувача та рядок з’єднання з базою даних. Для цього перейдіть у папку Task1-Server Створіть файл .env за прикладом (див. рис. 5.1) та додайте до нього наступні рядки, замінивши значення відповідно до ваших потреб:

 
Рисунок 5.1 – Приклад .env файлу

Для запуску серверної частини перейдіть у папку Task1-Server, відкрийте консоль та запустіть команду «docker compose up».
Для запуску IoT частини перейдіть у папку Task2-IoT, відкрийте консоль та запустіть команду «cargo run».
Для запуску клієнтської частини перейдіть у папку Task3-WebClient, відкрийте консоль та запустіть команду «npm run dev».


5.2 Призначення і логічна структура


Функції, які може виконувати програма, можна розбити на декілька модулів, а саме:
-	авторизація та реєстрація;
-	тварини;
-	види тварин;
-	показники;
-	аналітика;
-	експорт даних системи;
Модуль «Авторизація та реєстрація» надає можливість користувачам входити до системи та створювати нові облікові записи за допомогою логіну та пароля.. За замовчуванням доступ до адміністраторського облікового запису можливий за допомогою логіну "admin" та пароля "test".
Модуль «Тварини» містить у собі функції для перегляду, додавання, редагування та видалення тварин, за якими спостерігає користувач. 
Модуль «Види тварин» містить у собі функції для перегляду, додавання, редагування та видалення видів тварин.
Модуль «Показники» надає можливість переглядати дані, що надходять з IoT-пристроїв, які спостерігають за тваринами. Дозволяє додавати, редагувати та видаляти записи про показники тварин.
Модуль «Аналітика» генерує статистичні дані щодо стану тварин, визначає стан тварин на основі аналізу показників та надсилає сповіщення користувачам у разі виявлення проблем зі станом тварин.
Модуль «Експорт даних системи» є адміністраторським, і містить у собі функції для експорту даних системи.
	

5.3 Опис програмної реалізації


При відкритті клієнтського застосунка користувач бачить сторінку логіну (див. рис. 5.3).  На цій сторінці необхідно обрати: створити обліковий запис або увійти в систему.
Також у верху сайту можна налаштувати локалізацію сайту, натиснувши на відповідну кнопку у правому верхньому куті сайту. На вибір доступні англійська та українська мови. 

Рисунок 5.2 – Сторінка логіну

Після входу в систему користувач має доступ до функціоналу програмної системи. Головна сторінка зі списком всіх тварин, за якими спостерігає користувач та кнопки для їх редагування та видалення (див. рис 5.3).
 
Рисунок 5.3 – Сторінка з тваринами користувача

	Користувач може додати нову тварину на відповідній сторінці (див. рис. 5.4). 

Рисунок 5.4 – Сторінка додавання нової тварини

	Також користувач може додавати нові види тварин та критичні межі показників для цього виду (див. рис. 5.5)

Рисунок 5.5 – Сторінка додавання нового виду тварин

	Сторінка зі списком всіх видів тварин користувача та кнопки для їх редагування та видалення (див. рис. 5.6)

Рисунок 5.6 – Сторінка з видами тварин користувача
Якщо стан якоїсь із тварин не задовільний, то користувачу приходить сповіщення про це, яке він може переглянути у верхній панелі сайту натиснувши на відповідну піктограму (див. рис. 5.7)

Рисунок 5.7 – Сповіщення про незадовільний стан тварини

Натиснувши на ім’я тварини в табличці всіх тварин, користувач потрапляє на особисту сторінку кожної тварини (див. рис. 5.8). На ній є дані тварини, останній зібраний показник, а також таблиця з усіма зібраними показниками для цієї тварини.

Рисунок 5.8 – Особиста сторінка тварини

Натиснувши на посилання поруч зі станом тварини, користувач потрапляє на сторінку із зібраною аналітикою тварини (див. рис. 5.9). На ній є середні показники тварини, а також графіки кожного із показників.
 
Рисунок 5.9 – Сторінка з аналітикою тварини
	Далі розглянемо сторінку адміністратора. Після входу в систему з обліковим записом адміністратора, нас напрявляє на сторінку з кнопкою експорту даних системи (див. рис. 5.10).

Рисунок 5.10 – Головна сторінка з облікового запису адміністратора

При натисненні на кнопку «Експорт» завантажується файл «backup.sql», який містить копію бази даних програмної системи.
	Таким чином, було описано можливості взаємодії користувача з розробленою програмною системою.Запис результатів функціонального тестування доступний
за посиланням: https://www.youtube.com/watch?v=esl3zT7pQXg 


ВИСНОВКИ


За результатами виконання роботи було розроблено програмну систему на основі предметної області «Програмна система для контролю стану умов існування тварин на фермах».
У процесі роботи було проаналізовано предметну область, спроектовано структуру бази даних, розроблено архітектуру серверної, IoT та клієнтської частин програмної системи.
Розроблена програмна система забезпечує зручний доступ до інформації про стан ваших тварин, допомагає визначити й попередити проблеми зі здоров’ям у тварин, фермери отримують сповіщення про будь-які відхилення від нормальних показників здоров'я тварин, що дозволяє оперативно реагувати на потенційні проблеми, зібрані дані аналізуються для надання корисної статистики, що допомагає фермерам приймати обґрунтовані рішення щодо догляду за тваринами, підвищує продуктивність та прибутки, адже здорові тварини дають більше продукції (молока, м'яса, яєць), що веде до кращих фінансових результатів. Зручна та проста у використанні.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	Typescript documentation. URL: https://www.typescriptlang.org/docs/ (дата звернення: 15.06.2024).
2.	Nest.js documentation.  URL: https://docs.nestjs.com/ (дата звернення: 15.06.2024).
3.	Next.js documentation. URL: https://nextjs.org/docs (дата звернення: 15.06.2024).
4.	Rust documentation. URL: https://www.rust-lang.org/learn (дата звернення: 15.06.2024).
5.	Postgresql documentation. URL: https://www.postgresql.org/docs/ (дата звернення: 15.06.2024).
 
ДОДАТОК Б
Частина програмного коду 
	Б.1 Код сервісу, який відповідає за аналітику зібраних показників


1 import { Injectable } from '@nestjs/common';
2 import { PrismaService } from '../prisma';
3 import { AnalitycsDto, GetAnalitycsRequestDto } from './dtos';
4 import { NotificationService } from 'src/notifications/notifications.service';
5 import { CreateEditMetricDto } from 'src/metrics/dtos';
6 
7 @Injectable()
8 export class AnalitycsService {
9   constructor(
10     private readonly prismaService: PrismaService,
11     private readonly notificationService: NotificationService,
12   ) {}
13 
14   public async getAverageMetricsAnalitycs(
15     animalId: number,
16     req: GetAnalitycsRequestDto,
17   ): Promise<AnalitycsDto> {
18     const metrics = await this.prismaService.metric.findMany({
19       select: {
20         heartbeat: true,
21         respirationRate: true,
22         temperature: true,
23         animal: {
24           select: {
25             species: true,
26           },
27         },
28       },
29       orderBy: { timestamp: 'desc' },
30       where: {
31         animalId,
32         timestamp: {
33           ...(req.endDate && { lte: req.endDate }),
34           ...(req.startDate && { gte: req.startDate }),
35         },
36       },
37     });
38 
39     const { status } = this.getStatus(metrics);
40     const avgMetrics = metrics.reduce(
41       (acc, metric) => {
42         acc.avgHeartbeat += metric.heartbeat;
43         acc.avgRespirationRate += metric.respirationRate;
44         acc.avgTemperature += metric.temperature;
45         return acc;
46       },
47       {
48         avgHeartbeat: 0,
49         avgRespirationRate: 0,
50         avgTemperature: 0,
51       },
52     );
53 
54     avgMetrics.avgHeartbeat /= metrics.length;
55     avgMetrics.avgRespirationRate /= metrics.length;
56     avgMetrics.avgTemperature /= metrics.length;
57 
58     console.log(avgMetrics);
59     console.log(metrics);
60 
61     return {
62       id: animalId,
63       heartbeat: avgMetrics.avgHeartbeat,
64       respirationRate: avgMetrics.avgRespirationRate,
65       temperature: avgMetrics.avgTemperature,
66       status,
67     };
68   }
69 
70   public async getLastMetricsAnalytics(
71     req: CreateEditMetricDto,
72   ): Promise<{ status: string }> {
73     const metrics = await this.prismaService.metric.findMany({
74       select: {
75         heartbeat: true,
76         respirationRate: true,
77         temperature: true,
78         animal: {
79           select: {
80             id: true,
81             name: true,
82             species: true,
83             userId: true,
84           },
85         },
86       },
87       take: 1,
88       orderBy: { timestamp: 'desc' },
89       where: {
90         animalId: req.animalId,
91       },
92     });
93 
94     const animal = await this.prismaService.animal.findFirst({
95       select: {
96         id: true,
97         name: true,
98         species: true,
99         userId: true,
100       },
101       where: {
102         id: req.animalId,
103       },
104     });
105 
106     const status = this.getStatus([
107       ...metrics,
108       {
109         ...req,
110         animal,
111       },
112     ]);
113     await this.sendNotification(
114       status,
115       {
116         id: animal.id,
117         name: animal.name,
118       },
119       animal.userId,
120     );
121 
122     return {
123       status: status.status,
124     };
125   }
126 
127   private getStatus(
128     metrics: {
129       heartbeat: number;
130       respirationRate: number;
131       temperature: number;
132       animal?: {
133         species: {
134           id: number;
135           name: string;
136           description: string;
137           minHeartbeat: number;
138           maxHeartbeat: number;
139           minRespirationRate: number;
140           maxRespirationRate: number;
141           minTemperature: number;
142           maxTemperature: number;
143         };
144       };
145     }[],
146   ): { status: AnalitycsDto['status']; reasons: string[] } {
147     if (metrics.length === 0) {
148       return {
149         status: 'fine',
150         reasons: [],
151       };
152     }
153     console.log(metrics);
154 
155     const firstMetric = metrics[0];
156     const lastMetric = metrics[metrics.length - 1];
157 
158     const {
159       maxHeartbeat,
160       minHeartbeat,
161       maxRespirationRate,
162       minRespirationRate,
163       maxTemperature,
164       minTemperature,
165     } = lastMetric.animal.species;
166 
167     const reasons: string[] = [];
168 
169     // Define coefficients for each metric
170     const coeffs = {
171       heartbeat: 0.4,
172       respirationRate: 0.3,
173       temperature: 0.3,
174     };
175 
176     // Function to check thresholds and add reasons
177     const checkThresholds = (
178       metric: string,
179       value: number,
180       status: AnalitycsDto['status'],
181       min: number,
182       max: number,
183     ) => {
184       if (value > max) {
185         reasons.push(
186           status === 'critical'
187             ? `${metric} is critically high: ${value} (expected below ${max})`
188             : `${metric} is ${status} high: ${value}`,
189         );
190       } else if (value < min) {
191         reasons.push(
192           status === 'critical'
193             ? `${metric} is critically low: ${value} (expected above ${min})`
194             : `${metric} is ${status} low: ${value}`,
195         );
196       }
197     };
198 
199     // Function to check all thresholds and add reasons
200     const checkAllThresholds = (status: AnalitycsDto['status']) => {
201       checkThresholds(
202         'Heart rate',
203         lastMetric.heartbeat,
204         status,
205         minHeartbeat,
206         maxHeartbeat,
207       );
208       checkThresholds(
209         'Respiration rate',
210         lastMetric.respirationRate,
211         status,
212         minRespirationRate,
213         maxRespirationRate,
214       );
215       checkThresholds(
216         'Temperature',
217         lastMetric.temperature,
218         status,
219         minTemperature,
220         maxTemperature,
221       );
222     };
223 
224     // Calculate deviation percentage for a given metric
225     const calculateDeviationPercentage = (
226       value: number,
227       min: number,
228       max: number,
229     ) => {
230       if (value < min) {
231         return (min - value) / min;
232       } else if (value > max) {
233         return (value - max) / max;
234       } else {
235         return 0;
236       }
237     };
238 
239     // Calculate the difference percentage between the first and last metrics
240     const calculateDifferencePercentage = (initial: number, final: number) => {
241       return Math.abs(final - initial) / initial;
242     };
243 
244     // Calculate overall deviation score
245     const calculateDeviationScore = () => {
246       let score = 0;
247 
248       const heartbeatDeviation = calculateDeviationPercentage(
249         lastMetric.heartbeat,
250         minHeartbeat,
251         maxHeartbeat,
252       );
253       const respirationDeviation = calculateDeviationPercentage(
254         lastMetric.respirationRate,
255         minRespirationRate,
256         maxRespirationRate,
257       );
258       const temperatureDeviation = calculateDeviationPercentage(
259         lastMetric.temperature,
260         minTemperature,
261         maxTemperature,
262       );
263 
264       score += coeffs.heartbeat * Math.min(heartbeatDeviation, 1);
265       score += coeffs.respirationRate * Math.min(respirationDeviation, 1);
266       score += coeffs.temperature * Math.min(temperatureDeviation, 1);
267 
268       return score;
269     };
270 
271     // Calculate the differences between the first and last metrics
272     const heartbeatDifference = calculateDifferencePercentage(
273       firstMetric.heartbeat,
274       lastMetric.heartbeat,
275     );
276     const respirationDifference = calculateDifferencePercentage(
277       firstMetric.respirationRate,
278       lastMetric.respirationRate,
279     );
280     const temperatureDifference = calculateDifferencePercentage(
281       firstMetric.temperature,
282       lastMetric.temperature,
283     );
284 
285     const overallDeviationScore = calculateDeviationScore();
286 
287     // Define thresholds for differences to consider them significant
288     const significantDifferenceThreshold = 0.25;
289 
290     if (
291       heartbeatDifference > significantDifferenceThreshold ||
292       respirationDifference > significantDifferenceThreshold ||
293       temperatureDifference > significantDifferenceThreshold
294     ) {
295       reasons.push(
296         `Significant changes detected: Heartbeat difference ${heartbeatDifference.toFixed(
297           2,
298         )}, Respiration rate difference ${respirationDifference.toFixed(
299           2,
300         )}, Temperature difference ${temperatureDifference.toFixed(2)}`,
301       );
302       return { status: 'warning', reasons };
303     }
304 
305     if (overallDeviationScore >= 1.0) {
306       checkAllThresholds('critical');
307       return { status: 'critical', reasons };
308     }
309 
310     // Define thresholds for warning and ill statuses
311     const warningThreshold = 0.5;
312     const illThreshold = 0.75;
313 
314     if (overallDeviationScore >= illThreshold) {
315       checkAllThresholds('ill');
316       return { status: 'ill', reasons };
317     }
318 
319     if (overallDeviationScore >= warningThreshold) {
320       checkAllThresholds('warning');
321       return { status: 'warning', reasons };
322     }
323 
324     return { status: 'fine', reasons: [] };
325   }
326 
327   private async sendNotification(
328     { status, reasons }: { status: AnalitycsDto['status']; reasons: string[] },
329     animal: {
330       id: number;
331       name: string;
332     },
333     userId: number,
334   ) {
335     let message;
336 
337     if (status === 'critical') {
338       message = `${
339         animal.name
340       } appears to be in critical condition. Seek immediate veterinary care. Reasons: ${reasons?.join(
341         ', ',
342       )}`;
343     }
344 
345     if (status === 'warning') {
346       message = `We've noticed slight changes in ${
347         animal.name
348       } vital signs. Keep an eye on them and consult a veterinarian if they worsen. Reasons: ${reasons?.join(
349         ', ',
350       )}`;
351     }
352 
353     if (status === 'ill') {
354       message = `${
355         animal.name
356       } may be ill. We recommend contacting a veterinarian as soon as possible. Reasons: ${reasons?.join(
357         ', ',
358       )}`;
359     }
360 
361     if (status !== 'fine') {
362       this.notificationService.createNotification(
363         {
364           message,
365           animalId: animal.id,
366         },
367         userId,
368       );
369     }
370   }
371 }










ДОДАТОК В
Програмний код IoT пристрою
В.1 Код модулю, який відповідає за генерацію,аналітику та надсилання зібраних показників

1 use rand::Rng;
2 use serde::{Serialize};
3 use std::time::Duration;
4 use task_3_lib::{get_settings, get_device_data};
5 use task_3_lib::device_data::device_data::DeviceData;
6 use task_3_lib::settings::settings::Settings;
7 use tokio::time::interval;
8 use tokio::select;
9 
10 #[derive(Debug, Serialize)]
11 #[allow(non_snake_case)]
12 struct RequestPayload {
13   deviceId: u64,
14   respirationRate: f64,
15   temperature: f64,
16   heartbeat: f64,
17   timestamp: String,
18   animalId: u64,
19 }
20 
21 #[tokio::main]
22 async fn main() {
23     let settings = get_settings().unwrap();
24     let device_data = get_device_data().await.unwrap();
25 
26     let mut data_buffer: Vec<RequestPayload> = Vec::new();
27 
28     let mut rng = rand::thread_rng();
29 
30     let mut data_stream = interval(Duration::from_secs(settings.data_taking_rate));
31     let mut send_stream = interval(Duration::from_secs(settings.data_sending_rate));
32 
33     loop {
34         select! {
35             _ = send_stream.tick() => {
36                 if !data_buffer.is_empty() {
37                     send_batch_data(&data_buffer).await.unwrap();
38                     data_buffer.clear();
39                 }
40             },
41             _ = data_stream.tick() => {
42                 let payload = generate_payload(&device_data, &settings, &mut rng);
43 
44                 // Check for critical values
45                 if is_critical(&payload, &device_data) {
46                     send_critical_data(payload).await.unwrap();
47                 } else {
48                     data_buffer.push(payload);
49                 }
50             },
51         }
52     }
53 }
54 
55 // Function to check if a reading is critical
56 fn is_critical(payload: &RequestPayload, device_data: &DeviceData) -> bool {
57   payload.respirationRate < (device_data.min_respiration_rate as f64) ||
58   payload.respirationRate > (device_data.max_respiration_rate as f64) ||
59   payload.temperature < (device_data.min_temperature as f64) ||
60   payload.temperature > (device_data.max_temperature as f64) ||
61   payload.heartbeat < (device_data.min_heartbeat as f64) ||
62   payload.heartbeat > (device_data.max_heartbeat as f64)
63 }
64 
65 fn generate_payload(device_data: &DeviceData, settings:&Settings, rng: &mut impl Rng) -> RequestPayload {
66     let critical_threshold = 1.1;
67   
68     let respiration_rate = rng.gen_range(
69       (device_data.min_respiration_rate as f64)/critical_threshold..(device_data.max_respiration_rate as f64)*critical_threshold
70     );
71   
72     let temperature = rng.gen_range(
73         (device_data.min_temperature as f64)/critical_threshold..(device_data.max_temperature as f64)*critical_threshold
74     );
75   
76     let heartbeat = rng.gen_range(
77      (device_data.min_heartbeat as f64)/critical_threshold..(device_data.max_heartbeat as f64)*critical_threshold
78     );
79   
80     let timestamp = chrono::Utc::now().to_rfc3339();
81   
82     RequestPayload {
83       deviceId: device_data.device_id,
84       respirationRate:respiration_rate,
85       temperature,
86       heartbeat,
87       timestamp,
88       animalId: settings.animal_id,
89     }
90   }
91 
92 // Function to send a single data point
93 async fn send_critical_data(payload: RequestPayload) -> Result<reqwest::Response, reqwest::Error> {
94   let mut critical_data: Vec<RequestPayload> = Vec::new();
95   critical_data.push(payload);
96   let client = reqwest::Client::new();
97   let res = client
98     .post("http://localhost:3000/metric")
99     .json(&critical_data)
100     .send()
101     .await?;
102 
103   println!("Sent critical sensor data: {:?}", serde_json::to_string(&res.status().as_str()).unwrap());
104   Ok(res)
105 }
106 
107 // Function to send a batch of data points
108 async fn send_batch_data(data: &[RequestPayload]) -> Result<reqwest::Response, reqwest::Error> {
109   let client = reqwest::Client::new();
110   let res = client
111     .post("http://localhost:3000/metric")
112     .json(&data)
113     .send()
114     .await?;
115 
116   println!("Sent batch of sensor data: {:?}", serde_json::to_string(&res.status().as_str()).unwrap());
117   Ok(res)
118 }
 
ДОДАТОК Г
Програмний код клієнтської частини
Г.1 Код головної сторінки


1 import { AnimalDto } from "@/types";
2 import { fetchClient } from "@/utils/fetch";
3 import { formatDate } from "@/utils/format-date";
4 import Table from "@mui/material/Table";
5 import TableBody from "@mui/material/TableBody";
6 import TableCell from "@mui/material/TableCell";
7 import TableHead from "@mui/material/TableHead";
8 import TableRow from "@mui/material/TableRow";
9 import { Container, Stack, Typography, Link, IconButton } from "@mui/material";
10 import { DeleteButton } from "@/components";
11 import EditIcon from "@mui/icons-material/Edit";
12 import initTranslations from "../i18n";
13 
14 async function getData() {
15   return fetchClient.get<AnimalDto[]>("/animals");
16 }
17 
18 export default async function Home({
19   params: { locale },
20 }: {
21   params: { locale: string };
22 }) {
23   const [animals] = await Promise.all([getData()]);
24   const { t } = await initTranslations(locale);
25 
26   if (!animals) {
27     return null;
28   }
29 
30   return (
31     <Container maxWidth="xl">
32       <Stack gap={4}>
33         <Typography variant="h3">{t("allAnimals")}</Typography>
34         <Table sx={{ minWidth: 700 }} aria-label="customized table">
35           <TableHead>
36             <TableRow>
37               <TableCell>{t("name")}</TableCell>
38               <TableCell align="right">{t("species")}</TableCell>
39               <TableCell align="right">{t("gender")}</TableCell>
40               <TableCell align="right">{t("weight")}</TableCell>
41               <TableCell align="right">{t("dateOfBirth")}</TableCell>
42             </TableRow>
43           </TableHead>
44           <TableBody>
45             {animals.map((animal) => (
46               <TableRow key={animal.id}>
47                 <TableCell component="th" scope="row">
48                   <Link
49                     href={`/animals/${animal.id}`}
50                     variant="body1"
51                     underline="hover"
52                   >
53                     {animal.name}
54                   </Link>
55                 </TableCell>
56                 <TableCell align="right">{animal.species.name}</TableCell>
57                 <TableCell align="right">{t(animal.gender)}</TableCell>
58                 <TableCell align="right">{animal.weight}</TableCell>
59                 <TableCell align="right">
60                   {formatDate(animal.dateOfBirth)}
61                 </TableCell>
62                 <TableCell align="right">
63                   <IconButton href={`/animals/${animal.id}/edit`}>
64                     <EditIcon color="primary" />
65                   </IconButton>
66                   <DeleteButton path={`/animals/${animal.id}`} />
67                 </TableCell>
68               </TableRow>
69             ))}
70           </TableBody>
71         </Table>
72       </Stack>
73     </Container>
74   );
75 }


А.2 Код уніфікованого клієнту для HTTP-запитів


1 import { FetchError } from "./errors";
2 import type { RequestOptions } from "./types";
3 
4 const baseFetch = async <T>(
5   resource: string,
6   requestOptions: RequestOptions
7 ): Promise<T | never | undefined> => {
8   const { accessToken: _accessToken, config: customConfig } = requestOptions;
9 
10   let serverCookies;
11 
12   if (typeof window === "undefined") {
13     const { cookies } = await import("next/headers");
14     serverCookies = cookies();
15   }
16 
17   const config: RequestInit = {
18     credentials: "include",
19     ...customConfig,
20 
21     headers: {
22       "Content-Type": "application/json",
23       ...(serverCookies && { Cookie: serverCookies.toString() }),
24       ...customConfig?.headers,
25     },
26   };
27 
28   const url = `http://localhost:3000/${resource.replace(/^\/+|\/+$/g, "")}`;
29 
30   const response = await fetch(url, config);
31   const responseText = await response.text();
32 
33   try {
34     if (response.ok) {
35       return responseText ? JSON.parse(responseText) : {};
36     }
37 
38     const responseBody = JSON.parse(responseText);
39     throw new FetchError(
40       responseBody.message ||
41         "Error parsing fetch response - No response message",
42       {
43         method: config.method as string,
44         status: responseBody.statusCode || response.status,
45         url,
46       }
47     );
48   } catch (error) {
49     throw error;
50   }
51 };
52 
53 const get = async <T>(resource: string, requestOptions?: RequestOptions) =>
54   baseFetch<T>(resource, {
55     ...requestOptions,
56     config: {
57       ...requestOptions?.config,
58       method: "GET",
59     },
60   });
61 
62 const post = async <T = void>(
63   resource: string,
64   body?: Record<string, any>,
65   requestOptions?: RequestOptions
66 ) =>
67   baseFetch<T>(resource, {
68     ...requestOptions,
69     config: {
70       ...requestOptions?.config,
71       method: "POST",
72       body: body && JSON.stringify(body),
73     },
74   });
75 
76 const put = async <T = void>(
77   resource: string,
78   body?: Record<string, any>,
79   requestOptions?: RequestOptions
80 ) =>
81   baseFetch<T>(resource, {
82     ...requestOptions,
83     config: {
84       ...requestOptions?.config,
85       method: "PUT",
86       body: body && JSON.stringify(body),
87     },
88   });
89 
90 const delete$ = async <T = void>(
91   resource: string,
92   requestOptions?: RequestOptions
93 ) =>
94   baseFetch<T>(resource, {
95     ...requestOptions,
96     config: {
97       ...requestOptions?.config,
98       method: "DELETE",
99     },
100   });
101 
102 export const fetchClient = {
103   get,
104   post,
105   put,
106   delete$,
107 };



